---
description: Fetch data on each request with `getServerSideProps`.
---

# getServerSideProps（服務器端渲染）

如果您從頁面導出名為 getServerSideProps（服務器端渲染）的函數，Next.js 將使用 getServerSideProps 返回的數據在每個請求上預渲染此頁面。

```js
export async function getServerSideProps(context) {
  return {
    props: {}, // will be passed to the page component as props
  }
}
```

>請注意，無論呈現類型如何，任何`props`都將傳遞給頁面組件，並且可以在初始 HTML 中在客戶端查看。這是為了讓頁面正確[hydrated](https://reactjs.org/docs/react-dom.html#hydrate)。確保您沒有在 `props` 中傳遞任何不應在客戶端上可用的敏感信息

## getServerSideProps 何時執行

`getServerSideProps` 只會在伺服器端運行並不會在瀏覽器執行. 如果這個頁面使用`getServerSideProps`, 這時:

- 
當你直接請求這個頁面時，`getServerSideProps` 在請求的時候運行，這個頁面會和返回的 props 一起預渲染

- 當你在客戶端發送請求是透過 [`next/link`](/docs/api-reference/next/link.md)切換或是 [`next/router`](/docs/api-reference/next/router.md), Next.js 就會發送API請求到伺服器並運行`getServerSideProps`

`getServerSideProps` 會回傳JSON資料讓請求頁面去渲染. 所有的執行緒全部都由 Next.js自動化掌握, 所以只要你定義了`getServerSideProps`，你就不需要做任何額外的事情。

你可以使用 [next-code-elimination tool](https://next-code-elimination.vercel.app/) 去驗證 Next.js 從客戶端包中清除了什麼。

`getServerSideProps` 只能在**page**資料夾中匯出. 你不能在不是page的資料夾匯出這將會報錯.

請注意，您必須將 `getServerSideProps` 作為獨立函數導出 - 如果將 `getServerSideProps` 添加為頁面組件的props，它將**不起作用**。

The [`getServerSideProps` API reference](/docs/api-reference/data-fetching/get-server-side-props.md) covers all parameters and props that can be used with `getServerSideProps`.

## When should I use getServerSideProps

You should use `getServerSideProps` only if you need to render a page whose data must be fetched at request time. This could be due to the nature of the data or properties of the request (such as `authorization` headers or geo location). Pages using `getServerSideProps` will be server side rendered at request time and only be cached if [cache-control headers are configured](/docs/going-to-production#caching).

If you do not need to render the data during the request, then you should consider fetching data on the [client side](#fetching-data-on-the-client-side) or [`getStaticProps`](/docs/basic-features/data-fetching/get-static-props).

### getServerSideProps or API Routes

It can be tempting to reach for an [API Route](/docs/api-routes/introduction.md) when you want to fetch data from the server, then call that API route from `getServerSideProps`. This is an unnecessary and inefficient approach, as it will cause an extra request to be made due to both `getServerSideProps` and API Routes running on the server.

Take the following example. An API route is used to fetch some data from a CMS. That API route is then called directly from `getServerSideProps`. This produces an additional call, reducing performance. Instead, directly import the logic used inside your API Route into `getServerSideProps`. This could mean calling a CMS, database, or other API directly from inside `getServerSideProps`.

## Fetching data on the client side

If your page contains frequently updating data, and you don’t need to pre-render the data, you can fetch the data on the [client side](/docs/basic-features/data-fetching/client-side.md). An example of this is user-specific data:

- First, immediately show the page without data. Parts of the page can be pre-rendered using Static Generation. You can show loading states for missing data
- Then, fetch the data on the client side and display it when ready

This approach works well for user dashboard pages, for example. Because a dashboard is a private, user-specific page, SEO is not relevant and the page doesn’t need to be pre-rendered. The data is frequently updated, which requires request-time data fetching.

## Using getServerSideProps to fetch data at request time

The following example shows how to fetch data at request time and pre-render the result.

```jsx
function Page({ data }) {
  // Render data...
}

// This gets called on every request
export async function getServerSideProps() {
  // Fetch data from external API
  const res = await fetch(`https://.../data`)
  const data = await res.json()

  // Pass data to the page via props
  return { props: { data } }
}

export default Page
```

## Caching with Server-Side Rendering (SSR)

You can use caching headers (`Cache-Control`) inside `getServerSideProps` to cache dynamic responses. For example, using [`stale-while-revalidate`](https://web.dev/stale-while-revalidate/).

```jsx
// This value is considered fresh for ten seconds (s-maxage=10).
// If a request is repeated within the next 10 seconds, the previously
// cached value will still be fresh. If the request is repeated before 59 seconds,
// the cached value will be stale but still render (stale-while-revalidate=59).
//
// In the background, a revalidation request will be made to populate the cache
// with a fresh value. If you refresh the page, you will see the new value.
export async function getServerSideProps({ req, res }) {
  res.setHeader(
    'Cache-Control',
    'public, s-maxage=10, stale-while-revalidate=59'
  )

  return {
    props: {},
  }
}
```

學習更多關於 [快取](/docs/going-to-production).

## Does getServerSideProps render an error page

If an error is thrown inside `getServerSideProps`, it will show the `pages/500.js` file. Check out the documentation for [500 page](/docs/advanced-features/custom-error-page#500-page) to learn more on how to create it. During development this file will not be used and the dev overlay will be shown instead.

## Related

For more information on what to do next, we recommend the following sections:

<div className="card">
  <a href="/docs/api-reference/data-fetching/get-server-side-props.md">
    <b>getServerSideProps API Reference</b>
    <small>Read the API Reference for getServerSideProps</small>
  </a>
</div>

